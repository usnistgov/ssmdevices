:py:mod:`ssmdevices.software`
=============================

.. py:module:: ssmdevices.software


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   _networking/index.rst
   network_profiling/index.rst
   qxdm/index.rst
   windows/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   ssmdevices.software.IPerf2
   ssmdevices.software.IPerf3
   ssmdevices.software.IPerf2OnAndroid
   ssmdevices.software.IPerf2BoundPair
   ssmdevices.software.TrafficProfiler_ClosedLoopTCP
   ssmdevices.software.WLANInfo
   ssmdevices.software.WLANClient
   ssmdevices.software.QXDM



Functions
~~~~~~~~~

.. autoapisummary::

   ssmdevices.software.list_network_interfaces
   ssmdevices.software.network_interface_info
   ssmdevices.software.get_ipv4_occupied_ports
   ssmdevices.software.get_ipv4_address



Attributes
~~~~~~~~~~

.. autoapisummary::

   ssmdevices.software.INTERFACE_FIELDS


.. py:data:: INTERFACE_FIELDS
   :value: ('interface', 'ip_address', 'physical_address', 'ipv6_address')

   

.. py:function:: list_network_interfaces(by='interface')


.. py:function:: network_interface_info(resource)

   Try to look up the IP address of a network interface by its name
   or MAC (physical) address.

   If the interface does not exist, the medium is disconnected, or there
   is no IP address associated with the interface, raise `ConnectionError`.


.. py:function:: get_ipv4_occupied_ports(ip)


.. py:function:: get_ipv4_address(resource)

   Try to look up the IP address of a network interface by its name
   or MAC (physical) address.

   If the interface does not exist, the medium is disconnected, or there
   is no IP address associated with the interface, raise `ConnectionError`.


.. py:class:: IPerf2(resource=Undefined, **values)

   Bases: :py:obj:`_IPerfBase`

   Run an instance of iperf, collecting output data in a background thread.
   When running as an iperf client (server=False),
   The default value is the path that installs with 64-bit cygwin.

   .. py:attribute:: FLAGS

      

   .. py:attribute:: DATAFRAME_COLUMNS
      :value: ('jitter_milliseconds', 'datagrams_lost', 'datagrams_sent', 'datagrams_loss_percentage',...

      

   .. py:attribute:: bidirectional

      

   .. py:attribute:: report_style

      

   .. py:method:: profile(block=True)


   .. py:method:: read_stdout()

      retreive text from standard output, and parse into a pandas DataFrame if self.report_style is None


   .. py:method:: _format_output(stdout)

      pack stdout into a pandas DataFrame if self.report_style == 'C'



.. py:class:: IPerf3(resource=Undefined, **values)

   Bases: :py:obj:`_IPerfBase`

   Run an instance of iperf3, collecting output data in a background thread.
   When running as an iperf client (server=False),
   The default value is the path that installs with 64-bit cygwin.

   .. py:attribute:: FLAGS

      

   .. py:attribute:: reverse

      

   .. py:attribute:: json

      

   .. py:attribute:: zerocopy

      


.. py:class:: IPerf2OnAndroid(resource=Undefined, **values)

   Bases: :py:obj:`IPerf2`

   Run an instance of iperf, collecting output data in a background thread.
   When running as an iperf client (server=False),
   The default value is the path that installs with 64-bit cygwin.

   .. py:attribute:: remote_binary_path

      

   .. py:method:: profile(block=True)


   .. py:method:: open()

      Open an adb connection to the handset, copy the iperf binary onto the phone, and
      verify that iperf executes.


   .. py:method:: kill(wait_time=3)

      Kill the local process and the iperf process on the UE.


   .. py:method:: read_stdout()

      adb seems to forward stderr as stdout. Filter out some undesired
      resulting status messages.


   .. py:method:: wait_for_cell_data(timeout=60)

      Block until cellular data is available

      :param timeout: how long to wait for a connection before raising a Timeout error
      :return: None


   .. py:method:: reboot(block=True)

      Reboot the device.

      :param block: if truey, block until the device is ready to accept commands.


   .. py:method:: wait_for_device(timeout=30)

      Block until the device is ready to accept commands

      :return: None



.. py:class:: IPerf2BoundPair(resource=Undefined, **values)

   Bases: :py:obj:`IPerf2`

   Run an iperf client and a server on the host computer at the same time. They are
   bound to interfaces in order to ensure that data is routed between them, not through
   localhost or any other interface.

   .. py:attribute:: resource

      

   .. py:attribute:: server

      

   .. py:attribute:: client

      

   .. py:attribute:: children

      

   .. py:method:: open()

      The :meth:`open` method implements opening in the
      :class:`Device` object protocol. Call the
      :meth:`execute` method when open to
      execute the binary.


   .. py:method:: close()

      Backend implementations must overload this to disconnect an
      existing connection to the resource encapsulated in the object.


   .. py:method:: kill()

      If a process is running in the background, kill it. Sends a console
      warning if no process is running.


   .. py:method:: running()

      Check whether a background process is running.

      :returns: True if running, otherwise False


   .. py:method:: start()


   .. py:method:: read_stdout()

      retreive text from standard output, and parse into a pandas DataFrame if self.report_style is None


   .. py:method:: _merge_dataframes(client, server)


   .. py:method:: _setup_pair()



.. py:class:: TrafficProfiler_ClosedLoopTCP(resource=Undefined, **values)

   Bases: :py:obj:`TrafficProfiler_ClosedLoop`

   Profile closed-loop traffic between two network interfaces
   on this computer. Takes advantage of the system clock as a common
   basis for traffic delay measurement, with uncertainty approximately
   equal to the system time resolution.

   .. py:property:: _receive_interface


   .. py:attribute:: _server

      

   .. py:attribute:: PORT_WINERRS
      :value: (10013, 10048)

      

   .. py:attribute:: CONN_WINERRS
      :value: (10051,)

      

   .. py:method:: _close_sockets(*sockets, bytes_=0)


   .. py:method:: _open_sockets(buffer_size)

      Connect the supplied client socket to the server.


   .. py:method:: _run(client_sock, server_sock, buffer_size, duration=None, count=None, end_event=None)


   .. py:method:: profile_count(buffer_size: int, count: int)

      sends `count` buffers of size `buffer_size` bytes
      and returns profiling information"

      :param buffer_size: number of bytes to send in each buffer
      :type buffer_size: int
      :param count: the number of buffers to send
      :type count: int

      :returns: a DataFrame indexed on PC time containing columns 'bits_per_second', 'duration', 'delay', 'queuing_duration'


   .. py:method:: profile_duration(buffer_size: int, duration: float)

      sends buffers of size `buffer_size` bytes until
      `duration` seconds have elapsed, and returns profiling information"

      :param buffer_size: number of bytes to send in each buffer
      :type buffer_size: int
      :param duration: the minimum number of seconds to spend profiling
      :type duration: float

      :returns: a DataFrame indexed on PC time containing columns 'bits_per_second', 'duration', 'delay', 'queuing_duration'


   .. py:method:: _make_dataframe(worker_data)


   .. py:method:: mss()


   .. py:method:: mtu()


   .. py:method:: wait_for_interfaces(timeout)



.. py:class:: WLANInfo(resource=Undefined, **values)

   Bases: :py:obj:`labbench.ShellBackend`

   Parse calls to netsh to get information about WLAN interfaces.

   .. py:attribute:: FLAGS

      

   .. py:attribute:: only_bssid

      

   .. py:attribute:: interface

      

   .. py:method:: wait()


   .. py:method:: get_wlan_ssids(interface)


   .. py:method:: get_wlan_interfaces(name=None, param=None)



.. py:class:: WLANClient(resource=Undefined, **values)

   Bases: :py:obj:`labbench.Device`

   base class for labbench device wrappers.

   Drivers that subclass `Device` share

   * standardized connection management via context blocks (the `with` statement)
   * hooks for automatic data logging and heads-up displays
   * API style consistency
   * bounds checking and casting for typed attributes

   .. note::
       This `Device` base class has convenience
       functions for device control, but no implementation.

       Some wrappers for particular APIs labbench Device subclasses:

           * VISADevice: pyvisa,
           * ShellBackend: binaries and scripts
           * Serial: pyserial
           * DotNetDevice: pythonnet

       (and others). If you are implementing a driver that uses one of
       these backends, inherit from the corresponding class above, not
       `Device`.


   .. py:attribute:: resource

      

   .. py:attribute:: ssid

      

   .. py:attribute:: timeout

      

   .. py:method:: open()

      Backend implementations overload this to open a backend
      connection to the resource.


   .. py:method:: list_available_clients(by='interface')
      :classmethod:


   .. py:method:: _import_pywifi()
      :classmethod:


   .. py:method:: interface_connect()


   .. py:method:: interface_disconnect()

      Try to disconnect to the WLAN interface, or raise TimeoutError
      if there is no connection after the specified timeout.

      :param timeout: timeout to wait before raising TimeoutError
      :type timeout: float


   .. py:method:: interface_reconnect()

      Reconnect to the network interface.

      :return: time elapsed to reconnect


   .. py:method:: state()

      `True` if psutil reports that the interface is up


   .. py:method:: isup()

      `True` if psutil reports that the interface is up


   .. py:method:: transmit_rate_mbps()


   .. py:method:: signal()


   .. py:method:: description()


   .. py:method:: channel()


   .. py:method:: refresh()



.. py:class:: QXDM(resource=Undefined, **values)

   Bases: :py:obj:`labbench.Win32ComDevice`

   QXDM software wrapper

   .. py:attribute:: resource

      

   .. py:attribute:: cache_path

      

   .. py:attribute:: connection_timeout

      

   .. py:attribute:: ue_model_number

      

   .. py:attribute:: ue_mode

      

   .. py:attribute:: ue_imei

      

   .. py:attribute:: ue_esn

      

   .. py:attribute:: ue_build_id

      

   .. py:method:: open()

      Connect to the win32 com object


   .. py:method:: get_key(key, trait_name=None)

      implement this in subclasses to use `key` to retreive a parameter value from the
      Device with self.backend.

      property traits defined with "key=" call this to retrieve values
      from the backend.


   .. py:method:: close()

      Backend implementations must overload this to disconnect an
      existing connection to the resource encapsulated in the object.


   .. py:method:: configure(config_path, min_acquisition_time=None)

      Load the QXDM .dmc configuration file at the specified path,
      with adjustments that disable special file output modes like
      autosave, quicksave, and automatic segmenting based on time and
      file size.


   .. py:method:: save(path=None, saveNm=None)

      Stop the run and save the data in a file at the specified path.
      If path is None, autogenerate with self.cache_path and
      self.data_filename.

      This method is threadsafe.

      :returns: The absolute path to the data file


   .. py:method:: start(wait=True)

      Start acquisition, optionally waiting to return until
      new data enters the QXDM item store.


   .. py:method:: _get_com_port()


   .. py:method:: _load_config(path)


   .. py:method:: version()

      QXDM application version


   .. py:method:: _get_server_state()


   .. py:method:: _get_item_count()


   .. py:method:: _killall()

      kills all instances of qpst, qxdm, and atmnserver


   .. py:method:: _set_com_port(com_port: int)

      connects to the handset at the specified serial port.

      Blocks until QXDM confirms the phone is connected.

      :param com_port: serial port number, COMn; 0 or None to disable
      :type com_port: int

      :raises TimeoutError: after waiting `self.connection_timeout` for connection
      :raises IOError: when the QXDM COM API returns code -1


   .. py:method:: reconnect()


   .. py:method:: _clear(timeout=20)

      clears the buffer of data.

      TODO: Depending on if QXDM is already running, wait for the item
      count store to start increasing again?


   .. py:method:: _wait_for_stop(timeout=10)

      blocks until the QXDM item store stops growing


   .. py:method:: _wait_for_start(timeout=10, min_rows=10)

      blocks until the item store has grown by at least `min_rows`



