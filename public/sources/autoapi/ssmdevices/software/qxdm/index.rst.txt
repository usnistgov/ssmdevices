:py:mod:`ssmdevices.software.qxdm`
==================================

.. py:module:: ssmdevices.software.qxdm

.. autoapi-nested-parse::

   Basic control over the QXDM software.

   Author: Paul Blanchard (paul.blanchard@nist.gov)
   Edits by Dan Kuester (dkuester@nist.gov)



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   ssmdevices.software.qxdm.QXDM




.. py:class:: QXDM(resource=Undefined, **values)

   Bases: :py:obj:`labbench.Win32ComDevice`

   QXDM software wrapper

   .. py:attribute:: resource

      

   .. py:attribute:: cache_path

      

   .. py:attribute:: connection_timeout

      

   .. py:attribute:: ue_model_number

      

   .. py:attribute:: ue_mode

      

   .. py:attribute:: ue_imei

      

   .. py:attribute:: ue_esn

      

   .. py:attribute:: ue_build_id

      

   .. py:method:: open()

      Connect to the win32 com object


   .. py:method:: get_key(key, trait_name=None)

      implement this in subclasses to use `key` to retreive a parameter value from the
      Device with self.backend.

      property traits defined with "key=" call this to retrieve values
      from the backend.


   .. py:method:: close()

      Backend implementations must overload this to disconnect an
      existing connection to the resource encapsulated in the object.


   .. py:method:: configure(config_path, min_acquisition_time=None)

      Load the QXDM .dmc configuration file at the specified path,
      with adjustments that disable special file output modes like
      autosave, quicksave, and automatic segmenting based on time and
      file size.


   .. py:method:: save(path=None, saveNm=None)

      Stop the run and save the data in a file at the specified path.
      If path is None, autogenerate with self.cache_path and
      self.data_filename.

      This method is threadsafe.

      :returns: The absolute path to the data file


   .. py:method:: start(wait=True)

      Start acquisition, optionally waiting to return until
      new data enters the QXDM item store.


   .. py:method:: _get_com_port()


   .. py:method:: _load_config(path)


   .. py:method:: version()

      QXDM application version


   .. py:method:: _get_server_state()


   .. py:method:: _get_item_count()


   .. py:method:: _killall()

      kills all instances of qpst, qxdm, and atmnserver


   .. py:method:: _set_com_port(com_port: int)

      connects to the handset at the specified serial port.

      Blocks until QXDM confirms the phone is connected.

      :param com_port: serial port number, COMn; 0 or None to disable
      :type com_port: int

      :raises TimeoutError: after waiting `self.connection_timeout` for connection
      :raises IOError: when the QXDM COM API returns code -1


   .. py:method:: reconnect()


   .. py:method:: _clear(timeout=20)

      clears the buffer of data.

      TODO: Depending on if QXDM is already running, wait for the item
      count store to start increasing again?


   .. py:method:: _wait_for_stop(timeout=10)

      blocks until the QXDM item store stops growing


   .. py:method:: _wait_for_start(timeout=10, min_rows=10)

      blocks until the item store has grown by at least `min_rows`



