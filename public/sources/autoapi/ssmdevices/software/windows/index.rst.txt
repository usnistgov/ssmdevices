:py:mod:`ssmdevices.software.windows`
=====================================

.. py:module:: ssmdevices.software.windows


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   ssmdevices.software.windows.WLANInfo
   ssmdevices.software.windows.WLANClient




.. py:class:: WLANInfo(resource=Undefined, **values)

   Bases: :py:obj:`labbench.ShellBackend`

   Parse calls to netsh to get information about WLAN interfaces.

   .. py:attribute:: FLAGS

      

   .. py:attribute:: only_bssid

      

   .. py:attribute:: interface

      

   .. py:method:: wait()


   .. py:method:: get_wlan_ssids(interface)


   .. py:method:: get_wlan_interfaces(name=None, param=None)



.. py:class:: WLANClient(resource=Undefined, **values)

   Bases: :py:obj:`labbench.Device`

   base class for labbench device wrappers.

   Drivers that subclass `Device` share

   * standardized connection management via context blocks (the `with` statement)
   * hooks for automatic data logging and heads-up displays
   * API style consistency
   * bounds checking and casting for typed attributes

   .. note::
       This `Device` base class has convenience
       functions for device control, but no implementation.

       Some wrappers for particular APIs labbench Device subclasses:

           * VISADevice: pyvisa,
           * ShellBackend: binaries and scripts
           * Serial: pyserial
           * DotNetDevice: pythonnet

       (and others). If you are implementing a driver that uses one of
       these backends, inherit from the corresponding class above, not
       `Device`.


   .. py:attribute:: resource

      

   .. py:attribute:: ssid

      

   .. py:attribute:: timeout

      

   .. py:method:: open()

      Backend implementations overload this to open a backend
      connection to the resource.


   .. py:method:: list_available_clients(by='interface')
      :classmethod:


   .. py:method:: _import_pywifi()
      :classmethod:


   .. py:method:: interface_connect()


   .. py:method:: interface_disconnect()

      Try to disconnect to the WLAN interface, or raise TimeoutError
      if there is no connection after the specified timeout.

      :param timeout: timeout to wait before raising TimeoutError
      :type timeout: float


   .. py:method:: interface_reconnect()

      Reconnect to the network interface.

      :return: time elapsed to reconnect


   .. py:method:: state()

      `True` if psutil reports that the interface is up


   .. py:method:: isup()

      `True` if psutil reports that the interface is up


   .. py:method:: transmit_rate_mbps()


   .. py:method:: signal()


   .. py:method:: description()


   .. py:method:: channel()


   .. py:method:: refresh()



