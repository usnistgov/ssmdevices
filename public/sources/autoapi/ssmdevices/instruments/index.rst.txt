:py:mod:`ssmdevices.instruments`
================================

.. py:module:: ssmdevices.instruments


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   _minicircuits_usb/index.rst
   attenuators/index.rst
   gps_simulator/index.rst
   motors/index.rst
   network_analyzers/index.rst
   networking/index.rst
   oscilloscopes/index.rst
   power_sensors/index.rst
   power_supplies/index.rst
   signal_analyzers/index.rst
   signal_generators/index.rst
   switches/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   ssmdevices.instruments.MiniCircuitsRCDAT
   ssmdevices.instruments.SpirentGSS8000
   ssmdevices.instruments.AeroflexTM500
   ssmdevices.instruments.RohdeSchwarzZMBSeries
   ssmdevices.instruments.RigolOscilloscope
   ssmdevices.instruments.KeysightU2000XSeries
   ssmdevices.instruments.RohdeSchwarzNRP8s
   ssmdevices.instruments.RohdeSchwarzNRP18s
   ssmdevices.instruments.RohdeSchwarzNRPSeries
   ssmdevices.instruments.RigolDP800Series
   ssmdevices.instruments.RohdeSchwarzFSW26Base
   ssmdevices.instruments.RohdeSchwarzFSW26SpectrumAnalyzer
   ssmdevices.instruments.RohdeSchwarzFSW26IQAnalyzer
   ssmdevices.instruments.RohdeSchwarzFSW26LTEAnalyzer
   ssmdevices.instruments.RohdeSchwarzFSW26RealTime
   ssmdevices.instruments.RohdeSchwarzFSW43Base
   ssmdevices.instruments.RohdeSchwarzFSW43SpectrumAnalyzer
   ssmdevices.instruments.RohdeSchwarzFSW43IQAnalyzer
   ssmdevices.instruments.RohdeSchwarzFSW43LTEAnalyzer
   ssmdevices.instruments.RohdeSchwarzFSW43RealTime
   ssmdevices.instruments.RohdeSchwarzSMW200A
   ssmdevices.instruments.MiniCircuitsUSBSwitch
   ssmdevices.instruments.ETSLindgrenAzi2005




.. py:class:: MiniCircuitsRCDAT(resource=Undefined, **values)

   Bases: :py:obj:`_minicircuits_usb.SwitchAttenuatorBase`

   General control over MiniCircuits USB devices

   .. py:attribute:: _PID
      :value: 35

      

   .. py:attribute:: frequency

      

   .. py:attribute:: output_power_offset

      

   .. py:attribute:: calibration_path

      

   .. py:attribute:: channel

      

   .. py:attribute:: attenuation

      

   .. py:attribute:: output_power

      

   .. py:method:: attenuation_setting()


   .. py:method:: attenuation_setting(value)



.. py:class:: SpirentGSS8000(resource=Undefined, **values)

   Bases: :py:obj:`labbench.SerialDevice`

   Control a Spirent GPS GSS8000 simulator over a serial connection.

   Responses from the Spirent seem to be incompatible with
   pyvisa, so this driver uses plain serial.

   .. py:attribute:: resource

      

   .. py:method:: get_key(key, trait_name=None)

      implement this in subclasses to use `key` to retreive a parameter value from the
      Device with self.backend.

      property traits defined with "key=" call this to retrieve values
      from the backend.


   .. py:method:: load_scenario(path)

      Load a GPS scenario from a file stored on the instrument.

      :param path: Full path to scenario file on the instrument.



   .. py:method:: save_scenario(folderpath)

      Save the current GPS scenario to a file stored on the instrument.

      :param path: Full path to scenario file on the instrument.



   .. py:method:: fix_path_name(path)
      :staticmethod:


   .. py:method:: write(key, returns=None)

      Send a message to the spirent, and check the status message
      returned by the spirent.

      :return: Either 'value' (return the data response), 'status'
               (return the instrument status), or None (raise an
               exception if a data value is returned)


   .. py:method:: query(command)


   .. py:method:: run()

      Start running the current scenario. Requires that there is time left in
      the scenario, otherwise run `rewind()` first.


   .. py:method:: end()

      Stop running the current scenario. If a scenario is not
      running, an exception is raised.


   .. py:method:: rewind()

      Rewind the current scenario to the beginning.


   .. py:method:: abort()

      Force stop the current scenario.


   .. py:method:: reset()

      End any currently running scenario, then rewind


   .. py:method:: utc_time()

      UTC time of the running scenario


   .. py:method:: running()

      `True` if a scenario is running.


   .. py:method:: status()

      UTC time of the current running scenario.



.. py:class:: AeroflexTM500(resource=Undefined, **values)

   Bases: :py:obj:`labbench.TelnetDevice`

   Control an Aeroflex TM500 network tester with a
   telnet connection.

   The approach here is to iterate through lines of bytes, and
   add delays as needed for special cases as defined in the
   `delays` attribute.

   At some point, these lines should just be loaded directly
   from a file that could be treated as a config file.

   .. py:attribute:: timeout

      

   .. py:attribute:: ack_timeout

      

   .. py:attribute:: busy_retries

      

   .. py:attribute:: remote_ip

      

   .. py:attribute:: remote_ports

      

   .. py:attribute:: min_acquisition_time

      

   .. py:attribute:: port

      

   .. py:attribute:: config_root

      

   .. py:attribute:: data_root

      

   .. py:attribute:: convert_files

      

   .. py:method:: arm(scenario_name)

      Load the scenario from the command listing in a local TM500
      configuration file.
      The the full path to the configuration file is
      `os.path.join(self.config_root, self.config_file)+'.conf'`
      (on the host computer running this python instance).

      If the last script that was run is the same as the selected config
      script, then the script is loaded and sent to the TM500 only
      if force=True. It always runs on the first call after AeroflexTM500
      is instantiated.

      :returns: A list of responses to each command sent


   .. py:method:: trigger()

      Start logging and return the path to the directory where the data
      is being saved.


   .. py:method:: stop(convert=True)

      Stop logging.
      :param bool convert: Whether to convert the output binary files to text

      :returns: If convert=True, a dictionary of {'name': path} items pointing to the converted text output


   .. py:method:: reboot(timeout=180)

      Reboot the TMA and TM500 hardware.


   .. py:method:: command_log_to_script(path)
      :staticmethod:

      Scrape a script out of a TM500 "screen save" text file. The output
      for an input that takes the form <path>/<to>/<filename>.txt
      will be <path>/<to>/<filename>-script.txt.


   .. py:method:: close()

      Disconnect the telnet connection


   .. py:method:: open()

      Open a telnet connection to the host defined
      by the string in self.resource


   .. py:method:: _tma_is_connected()


   .. py:method:: _reconnect(force=False)

      Ensure the TMA software is connected to the TM500


   .. py:method:: _block_until_min_acquisition()

      Make sure the minimum acquisition time has elapsed to avoid putting
      the TM500 in a sad state


   .. py:method:: _send(msg, data_lines=1, confirm=True, timeout=None)

      Send a message, then block until a confirmation message is received.

      :param msg: str or bytes containing the message to send
      :param int data_lines: number of lines in the response string

      :returns: decoded string containing the response


   .. py:method:: _convert_to_text()

      Convert the latest data to text


   .. py:method:: _read_until(rsp, timeout=None)



.. py:class:: RohdeSchwarzZMBSeries(resource=Undefined, **values)

   Bases: :py:obj:`labbench.VISADevice`

   A network analyzer.

   Author: Audrey Puls

   .. py:attribute:: initiate_continuous

      

   .. py:method:: clear()


   .. py:method:: save_trace_to_csv(path, trace=1)

      Save the specified trace to a csv file on the instrument.
      Block until the operation is finished.


   .. py:method:: trigger()

      Initiate a software trigger.

      Consider setting `state.initiate_continuous = False` first so that the
      instrument waits for this trigger before starting a sweep.



.. py:class:: RigolOscilloscope(resource=Undefined, **values)

   Bases: :py:obj:`labbench.VISADevice`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource

   .. py:attribute:: time_offset

      

   .. py:attribute:: time_scale

      

   .. py:method:: open(horizontal=False)

      opens the instrument.

      When managing device connection through a `with` context,
      this is called automatically and does not need
      to be invoked.


   .. py:method:: fetch()


   .. py:method:: fetch_rms()



.. py:class:: KeysightU2000XSeries(resource=Undefined, **values)

   Bases: :py:obj:`labbench.VISADevice`

   This is my cool driver for Keysight U2040 X-Series power sensors

   .. py:attribute:: TRIGGER_SOURCES
      :value: ('IMM', 'INT', 'EXT', 'BUS', 'INT1')

      

   .. py:attribute:: initiate_continuous

      

   .. py:attribute:: output_trigger

      

   .. py:attribute:: trigger_source

      

   .. py:attribute:: trigger_count

      

   .. py:attribute:: measurement_rate

      

   .. py:attribute:: sweep_aperture

      

   .. py:attribute:: frequency

      

   .. py:method:: preset()

      sends '*RST' to reset the instrument to preset


   .. py:method:: fetch()

      Return a single number or pandas Series containing the power readings


   .. py:method:: __imports__()
      :classmethod:



.. py:class:: RohdeSchwarzNRP8s(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzNRPSeries`

   Requires drivers from the R&S website; resource strings for connections take the form
   'RSNRP::0x00e2::103892::INSTR'.

   .. py:attribute:: frequency

      


.. py:class:: RohdeSchwarzNRP18s(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzNRPSeries`

   Requires drivers from the R&S website; resource strings for connections take the form
   'RSNRP::0x00e2::103892::INSTR'.

   .. py:attribute:: frequency

      


.. py:class:: RohdeSchwarzNRPSeries(resource=Undefined, **values)

   Bases: :py:obj:`labbench.VISADevice`

   Requires drivers from the R&S website; resource strings for connections take the form
   'RSNRP::0x00e2::103892::INSTR'.

   .. py:attribute:: FUNCTIONS
      :value: ('POW:AVG', 'POW:BURS:AVG', 'POW:TSL:AVG', 'XTIM:POW', 'XTIM:POWer')

      

   .. py:attribute:: TRIGGER_SOURCES
      :value: ('HOLD', 'IMM', 'INT', 'EXT', 'EXT1', 'EXT2', 'BUS', 'INT1')

      

   .. py:attribute:: frequency

      

   .. py:attribute:: initiate_continuous

      

   .. py:attribute:: trigger_delay

      

   .. py:attribute:: trigger_count

      

   .. py:attribute:: trigger_holdoff

      

   .. py:attribute:: trigger_level

      

   .. py:attribute:: trace_points

      

   .. py:attribute:: trace_realtime

      

   .. py:attribute:: trace_time

      

   .. py:attribute:: trace_offset_time

      

   .. py:attribute:: trace_average_count

      

   .. py:attribute:: trace_average_mode

      

   .. py:attribute:: trace_average_enable

      

   .. py:attribute:: average_count

      

   .. py:attribute:: average_auto

      

   .. py:attribute:: average_enable

      

   .. py:attribute:: smoothing_enable

      

   .. py:attribute:: read_termination

      

   .. py:method:: function(value)


   .. py:method:: trigger_source()

      'HOLD: No trigger; IMM: Software; INT: Internal level trigger; EXT2: External trigger, 10 kOhm


   .. py:method:: preset()

      sends '*RST' to reset the instrument to preset


   .. py:method:: trigger_single()


   .. py:method:: fetch()

      Return a single number or pandas Series containing the power readings


   .. py:method:: fetch_buffer()

      Return a single number or pandas Series containing the power readings


   .. py:method:: setup_trace(frequency, trace_points, sample_period, trigger_level, trigger_delay, trigger_source)

      :param frequency: in Hz
      :param trace_points: number of points in the trace (perhaps as high as 5000)
      :param sample_period: in s
      :param trigger_level: in dBm
      :param trigger_delay: in s
      :param trigger_source: 'HOLD: No trigger; IMM: Software; INT: Internal level trigger; EXT2: External trigger, 10 kOhm'
      :return: None


   .. py:method:: __imports__()
      :classmethod:



.. py:class:: RigolDP800Series(resource=Undefined, **values)

   Bases: :py:obj:`labbench.VISADevice`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource

   .. py:attribute:: REMAP_BOOL

      

   .. py:attribute:: enable1

      

   .. py:attribute:: enable2

      

   .. py:attribute:: enable3

      

   .. py:attribute:: voltage_setting1

      

   .. py:attribute:: voltage_setting2

      

   .. py:attribute:: voltage_setting3

      

   .. py:attribute:: voltage1

      

   .. py:attribute:: voltage2

      

   .. py:attribute:: voltage3

      

   .. py:attribute:: current1

      

   .. py:attribute:: current2

      

   .. py:attribute:: current3

      

   .. py:method:: open()

      Poll *IDN until the instrument responds.
      Sometimes it needs an extra poke before it responds.


   .. py:method:: get_key(scpi_key, trait_name=None)

      This instrument expects keys to have syntax ":COMMAND? PARAM",
      instead of ":COMMAND PARAM?" as implemented in lb.VISADevice.

      Insert the "?" in the appropriate place here.


   .. py:method:: set_key(scpi_key, value, trait_name=None)

      This instrument expects sets to have syntax :COMMAND? PARAM,VALUE
      instead of :COMMAND PARAM VALUE? as implemented in lb.VISADevice.

      Implement this behavior here.



.. py:class:: RohdeSchwarzFSW26Base(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzFSWBase`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource

   .. py:attribute:: frequency_center

      

   .. py:attribute:: frequency_span

      

   .. py:attribute:: frequency_start

      

   .. py:attribute:: frequency_stop

      

   .. py:attribute:: resolution_bandwidth

      


.. py:class:: RohdeSchwarzFSW26SpectrumAnalyzer(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzFSW26Base`, :py:obj:`RohdeSchwarzSpectrumAnalyzerMixIn`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource


.. py:class:: RohdeSchwarzFSW26IQAnalyzer(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzFSW26Base`, :py:obj:`RohdeSchwarzIQAnalyzerMixIn`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource


.. py:class:: RohdeSchwarzFSW26LTEAnalyzer(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzFSW26Base`, :py:obj:`RohdeSchwarzLTEAnalyzerMixIn`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource


.. py:class:: RohdeSchwarzFSW26RealTime(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzFSW26Base`, :py:obj:`RohdeSchwarzRealTimeMixIn`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource


.. py:class:: RohdeSchwarzFSW43Base(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzFSWBase`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource

   .. py:attribute:: frequency_center

      

   .. py:attribute:: frequency_span

      

   .. py:attribute:: frequency_start

      

   .. py:attribute:: frequency_stop

      

   .. py:attribute:: resolution_bandwidth

      


.. py:class:: RohdeSchwarzFSW43SpectrumAnalyzer(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzFSW43Base`, :py:obj:`RohdeSchwarzSpectrumAnalyzerMixIn`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource


.. py:class:: RohdeSchwarzFSW43IQAnalyzer(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzFSW43Base`, :py:obj:`RohdeSchwarzIQAnalyzerMixIn`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource


.. py:class:: RohdeSchwarzFSW43LTEAnalyzer(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzFSW43Base`, :py:obj:`RohdeSchwarzLTEAnalyzerMixIn`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource


.. py:class:: RohdeSchwarzFSW43RealTime(resource=Undefined, **values)

   Bases: :py:obj:`RohdeSchwarzFSW43Base`, :py:obj:`RohdeSchwarzRealTimeMixIn`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource


.. py:class:: RohdeSchwarzSMW200A(resource=Undefined, **values)

   Bases: :py:obj:`labbench.VISADevice`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource

   .. py:attribute:: frequency_center

      

   .. py:attribute:: rf_output_power

      

   .. py:attribute:: rf_output_enable

      

   .. py:method:: save_state(FileName, num='4')

      Save current state of the device to the default directory.
      :param FileName: state file location on the instrument
      :type FileName: string

      :param num: state number in the saved filename
      :type num: int



   .. py:method:: load_state(FileName, opc=False, num='4')

      Loads a previously saved state file in the instrument

      :param FileName: state file location on the instrument
      :type FileName: string

      :param opc: set the VISA op complete flag?
      :type opc: bool

      :param num: state number in the saved filename
      :type num: int



.. py:class:: MiniCircuitsUSBSwitch(resource=Undefined, **values)

   Bases: :py:obj:`labbench.DotNetDevice`

   A digitally controlled solid-state switch.

   This implementation calls the .NET drivers provided by the
   manufacturer instead of the recommended C DLL drivers in order to
   support 64-bit python.

   The .NET documentation is located here:
   https://www.minicircuits.com/softwaredownload/Prog_Manual-Solid_State_Switch.pdf

   .. py:method:: open()

      Open the device resource.


   .. py:method:: close()

      Release the attenuator hardware resource via the driver DLL.


   .. py:method:: port()


   .. py:method:: port(value)



.. py:class:: ETSLindgrenAzi2005(resource=Undefined, **values)

   Bases: :py:obj:`labbench.VISADevice`

   base class for VISA device wrappers with pyvisa.

   .. rubric:: Examples

   Autodetect a list of valid `resource` strings on the host::

       print(VISADevice.list_resources())

   Fetch the instrument identity string::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.identity)

   Write ':FETCH?' to the instrument, read an expected ASCII CSV response,
   and return it as a pandas DataFrame::

       with VISADevice('USB0::0x2A8D::0x1E01::SG56360004::INSTR') as instr:
           print(inst.query_ascii_values(':FETCH?'))

   See also:
   .. _installing a proprietary OS service for VISA:
       https://pyvisa.readthedocs.io/en/latest/faq/getting_nivisa.html#faq-getting-nivisa
   .. _resource strings and basic configuration:
       https://pyvisa.readthedocs.io/en/latest/introduction/communication.html#getting-the-instrument-configuration-right

   .. attribute:: backend

      instance of a pyvisa instrument object (when open)

      :type: pyvisa.Resource

   .. py:attribute:: timeout

      

   .. py:attribute:: baud_rate

      

   .. py:attribute:: parity

      

   .. py:attribute:: stopbits

      

   .. py:attribute:: xonxoff

      

   .. py:attribute:: rtscts

      

   .. py:attribute:: dsrdtr

      

   .. py:attribute:: read_termination

      

   .. py:attribute:: write_termination

      

   .. py:attribute:: speed

      

   .. py:attribute:: cwlimit

      

   .. py:attribute:: cclimit

      

   .. py:attribute:: define_position

      

   .. py:attribute:: position

      

   .. py:method:: config(mode)


   .. py:method:: whereami()


   .. py:method:: wheredoigo()


   .. py:method:: set_speed(value)


   .. py:method:: set_limits(side, value)

      Probably should put some error checking in here to make sure value is a float
      Also, note we use write here becuase property.setter inserts a space


   .. py:method:: set_position(value)


   .. py:method:: seek(value)


   .. py:method:: stop()


   .. py:method:: set_key(key, value, trait_name=None)

      writes an SCPI message to set a parameter with a name key
      to `value`.

      The command message string is formatted as f'{scpi_key} {value}'. This
      This is automatically called on assignment to property traits that
      are defined with 'key='.

      :param scpi_key: the name of the parameter to set
      :type scpi_key: str
      :param value: value to assign
      :type value: str
      :param name: name of the trait setting the key (or None to indicate no trait) (ignored)
      :type name: str, None



